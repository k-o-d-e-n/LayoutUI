//
//  Generated by GYB.
//

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

public struct VStackReducer<Elements>: LayoutReducer where Elements: Sequence {
    @usableFromInline
    let initialResult: Int
    @usableFromInline
    let data: Elements
    @usableFromInline
    let spacing: CGFloat
    @usableFromInline
    init(_ data: Elements, initial result: Int, spacing: CGFloat) {
        self.initialResult = result
        self.data = data
        self.spacing = spacing
    }
    @inlinable
    @inline(__always)
    public func reduce<Sublayout>(_ bounds: CGRect, scheme: (Int, Elements.Element) -> Sublayout) where Sublayout: SublayoutProtocol {
        var filled: CGFloat = 0
        var rects: [(CGRect, Sublayout, Bool)] = []
        let idOffset = initialResult
        var flexibleCount: CGFloat = 0
        for (i, element) in data.enumerated() {
            let l = scheme(idOffset + i, element)
            let fixed = l.isFixedHeight
            let r = l.rect(in: bounds)
            rects.append((r, l, fixed))
            if fixed {
                filled += r.height + spacing
            } else {
                flexibleCount += 1
            }
        }
        let free = bounds.height - filled + spacing
        let flexibleSize: CGFloat
        var offset: CGFloat
        if free <= 0 || flexibleCount == 0 {
            flexibleSize = 0
            offset = free / 2 + bounds.minY
        } else {
            flexibleSize = (free / flexibleCount) - spacing
            offset = bounds.minY
        }
        for (i, el) in rects.enumerated() {
            let size = el.2 ? el.0.height : flexibleSize
            offset += i > 0 ? spacing : 0
            let rect = CGRect(
                x: el.0.minX, y: offset,
                width: el.0.width, height: size
            )
            el.1.place(in: rect)
            offset += size
        }
    }
    @inlinable
    @inline(__always)
    public func forEach(_ next: (Int, Elements.Element) -> Void) {
        let idOffset = initialResult
        for (i, element) in data.enumerated() {
            next(idOffset + i, element)
        }
    }
}
extension Reduce {
    @inlinable
    @inline(__always)
    public init<C>(
        id: Int? = nil, horizontalStack elements: C, spacing: CGFloat = 0,
        @LayoutBuilder scheme: @escaping (Int, C.Element) -> Scheme
    ) where Reducer == VStackReducer<C> {
        self.init(id: id, reducer: VStackReducer(elements, initial: id.map({ $0 + 1 }) ?? 0, spacing: spacing), scheme: scheme)
    }
}
extension VStackReducer {
    @inlinable
    @inline(__always)
    public init(spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Elements) where Elements: CompoundLayout {
        self.init(scheme(), initial: 0, spacing: spacing)
    }
}
public typealias VStack<Content> = Reduce<VStackReducer<Content>, Content.Sublayout> where Content: CompoundLayout
extension VStack {
    @inlinable
    @inline(__always)
    public init<Content>(id: Int? = nil, spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Content) where Content: CompoundLayout, Reducer == VStackReducer<Content>, Scheme == Content.Sublayout {
        self.init(id: id, reducer: VStackReducer(spacing: spacing, scheme: scheme), scheme: { _, el in el })
    }
}
public struct HStackReducer<Elements>: LayoutReducer where Elements: Sequence {
    @usableFromInline
    let initialResult: Int
    @usableFromInline
    let data: Elements
    @usableFromInline
    let spacing: CGFloat
    @usableFromInline
    init(_ data: Elements, initial result: Int, spacing: CGFloat) {
        self.initialResult = result
        self.data = data
        self.spacing = spacing
    }
    @inlinable
    @inline(__always)
    public func reduce<Sublayout>(_ bounds: CGRect, scheme: (Int, Elements.Element) -> Sublayout) where Sublayout: SublayoutProtocol {
        var filled: CGFloat = 0
        var rects: [(CGRect, Sublayout, Bool)] = []
        let idOffset = initialResult
        var flexibleCount: CGFloat = 0
        for (i, element) in data.enumerated() {
            let l = scheme(idOffset + i, element)
            let fixed = l.isFixedWidth
            let r = l.rect(in: bounds)
            rects.append((r, l, fixed))
            if fixed {
                filled += r.width + spacing
            } else {
                flexibleCount += 1
            }
        }
        let free = bounds.width - filled + spacing
        let flexibleSize: CGFloat
        var offset: CGFloat
        if free <= 0 || flexibleCount == 0 {
            flexibleSize = 0
            offset = free / 2 + bounds.minX
        } else {
            flexibleSize = (free / flexibleCount) - spacing
            offset = bounds.minX
        }
        for (i, el) in rects.enumerated() {
            let size = el.2 ? el.0.width : flexibleSize
            offset += i > 0 ? spacing : 0
            let rect = CGRect(
                x: offset, y: el.0.minY,
                width: size, height: el.0.height
            )
            el.1.place(in: rect)
            offset += size
        }
    }
    @inlinable
    @inline(__always)
    public func forEach(_ next: (Int, Elements.Element) -> Void) {
        let idOffset = initialResult
        for (i, element) in data.enumerated() {
            next(idOffset + i, element)
        }
    }
}
extension Reduce {
    @inlinable
    @inline(__always)
    public init<C>(
        id: Int? = nil, horizontalStack elements: C, spacing: CGFloat = 0,
        @LayoutBuilder scheme: @escaping (Int, C.Element) -> Scheme
    ) where Reducer == HStackReducer<C> {
        self.init(id: id, reducer: HStackReducer(elements, initial: id.map({ $0 + 1 }) ?? 0, spacing: spacing), scheme: scheme)
    }
}
extension HStackReducer {
    @inlinable
    @inline(__always)
    public init(spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Elements) where Elements: CompoundLayout {
        self.init(scheme(), initial: 0, spacing: spacing)
    }
}
public typealias HStack<Content> = Reduce<HStackReducer<Content>, Content.Sublayout> where Content: CompoundLayout
extension HStack {
    @inlinable
    @inline(__always)
    public init<Content>(id: Int? = nil, spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Content) where Content: CompoundLayout, Reducer == HStackReducer<Content>, Scheme == Content.Sublayout {
        self.init(id: id, reducer: HStackReducer(spacing: spacing, scheme: scheme), scheme: { _, el in el })
    }
}
