%{
axes = ['V', 'H']
}%
//
//  Generated by GYB.
//

#if os(iOS) || os(tvOS) || os(watchOS)
import CoreGraphics
#else
import Foundation
#endif

% for axis in axes:
%{
dimension = 'Width' if axis == 'H' else 'Height'
minSide = 'minX' if axis == 'H' else 'minY'
name = axis + 'StackReducer'
}%
public struct ${name}<Elements>: LayoutReducer where Elements: Sequence {
    @usableFromInline
    let initialResult: Int
    @usableFromInline
    let data: Elements
    @usableFromInline
    let spacing: CGFloat
    @usableFromInline
    init(_ data: Elements, initial result: Int, spacing: CGFloat) {
        self.initialResult = result
        self.data = data
        self.spacing = spacing
    }
    @inlinable
    @inline(__always)
    public func reduce<Sublayout>(_ bounds: CGRect, scheme: (Int, Elements.Element) -> Sublayout) where Sublayout: SublayoutProtocol {
        var filled: CGFloat = 0
        var rects: [(CGRect, Sublayout, Bool)] = []
        let idOffset = initialResult
        var flexibleCount: CGFloat = 0
        for (i, element) in data.enumerated() {
            let l = scheme(idOffset + i, element)
            let fixed = l.isFixed${dimension}
            let r = l.rect(in: bounds)
            rects.append((r, l, fixed))
            if fixed {
                filled += r.${dimension.lower()} + spacing
            } else {
                flexibleCount += 1
            }
        }
        let free = bounds.${dimension.lower()} - filled + spacing
        let flexibleSize: CGFloat
        var offset: CGFloat
        if free <= 0 || flexibleCount == 0 {
            flexibleSize = 0
            offset = free / 2 + bounds.${minSide}
        } else {
            flexibleSize = (free / flexibleCount) - spacing
            offset = bounds.${minSide}
        }
        for (i, el) in rects.enumerated() {
            let size = el.2 ? el.0.${dimension.lower()} : flexibleSize
            offset += i > 0 ? spacing : 0
            let rect = CGRect(
                x: ${'offset' if axis == 'H' else 'el.0.minX'}, y: ${'offset' if axis == 'V' else 'el.0.minY'},
                width: ${'size' if axis == 'H' else 'el.0.width'}, height: ${'size' if axis == 'V' else 'el.0.height'}
            )
            el.1.place(in: rect)
            offset += size
        }
    }
    @inlinable
    @inline(__always)
    public func forEach(_ next: (Int, Elements.Element) -> Void) {
        let idOffset = initialResult
        for (i, element) in data.enumerated() {
            next(idOffset + i, element)
        }
    }
}
extension Reduce {
    @inlinable
    @inline(__always)
    public init<C>(
        id: Int? = nil, horizontalStack elements: C, spacing: CGFloat = 0,
        @LayoutBuilder scheme: @escaping (Int, C.Element) -> Scheme
    ) where Reducer == ${name}<C> {
        self.init(id: id, reducer: ${name}(elements, initial: id.map({ $0 + 1 }) ?? 0, spacing: spacing), scheme: scheme)
    }
}
extension ${name} {
    @inlinable
    @inline(__always)
    public init(spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Elements) where Elements: CompoundLayout {
        self.init(scheme(), initial: 0, spacing: spacing)
    }
}
public typealias ${axis}Stack<Content> = Reduce<${name}<Content>, Content.Sublayout> where Content: CompoundLayout
extension ${axis}Stack {
    @inlinable
    @inline(__always)
    public init<Content>(id: Int? = nil, spacing: CGFloat = 0, @LayoutBuilder scheme: () -> Content) where Content: CompoundLayout, Reducer == ${name}<Content>, Scheme == Content.Sublayout {
        self.init(id: id, reducer: ${name}(spacing: spacing, scheme: scheme), scheme: { _, el in el })
    }
}
% end
