%{
side_elements = ['MinX', 'MaxX', 'MinY', 'MaxY', 'MidX', 'MidY']
}%
///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

// TODO: Move all implementations to Before/After namespaces

% for element in side_elements:
%{
ismin = element.startswith('Min')
ismid = element.startswith('Mid')
isX = element.endswith('X')
axis = element[-1]
dimension = 'width' if isX else 'height'
side = element[:-1].lower() + element[-1]
contrside = 'max' + axis if ismin else 'min' + axis if not ismid else side
}%
%{
_contrside = contrside[0].upper() + contrside[1:]
anchor1_typealias = _contrside if ismin else element if not ismid else 'Min' + axis
anchor1_typealias_value = 'After' if ismid else 'Before'
anchor2_typealias = element if ismin else _contrside if not ismid else 'Max' + axis
anchor2_typealias_value = 'Before' if ismid else 'After'
}%
extension ${element} {
    public enum Limit {}
    public enum Pull {}
}
extension ${element}.Limit {
    public typealias ${anchor1_typealias} = LayoutUI.${element}.${anchor1_typealias_value}.Limit
    public typealias ${anchor2_typealias} = LayoutUI.${element}.${anchor2_typealias_value}.Limit
}
extension ${element}.Pull {
    public typealias ${anchor1_typealias} = LayoutUI.${element}.${anchor1_typealias_value}.Pull
    public typealias ${anchor2_typealias} = LayoutUI.${element}.${anchor2_typealias_value}.Pull
}
extension ${element}.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
            #let anchorPosition = anchor.get(for: rect, in: axis)
            #axis.set(size: max(0, min(axis.get(sizeAt: sourceRect), anchorPosition - axis.get(minOf: sourceRect))), for: &sourceRect)
            #axis.set(origin: min(anchorPosition, axis.get(minOf: sourceRect)), for: &sourceRect)
            }%
            let anchor = source.${side}
            rect.size.${dimension} = max(0, min(rect.${dimension}, anchor - rect.min${axis}))
            rect.origin.${axis.lower()} = min(anchor, rect.min${axis})
        }
    }
}
extension ${element}.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
            #let anchorPosition = anchor.get(for: rect, in: axis)
            #axis.set(size: max(0, min(axis.get(sizeAt: sourceRect), axis.get(maxOf: sourceRect) - anchorPosition)), for: &sourceRect)
            #axis.set(origin: max(anchorPosition, axis.get(minOf: sourceRect)), for: &sourceRect)
            }%
            let anchor = source.${side}
            rect.size.${dimension} = max(0, min(rect.${dimension}, rect.max${axis} - anchor))
            rect.origin.${axis.lower()} = max(anchor, rect.min${axis})
        }
    }
}
extension ${element}.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
            #let anchorPosition = anchor.get(for: rect, in: axis)
            #axis.set(size: max(0, anchorPosition - axis.get(minOf: sourceRect)), for: &sourceRect)
            #axis.set(origin: anchorPosition - axis.get(sizeAt: sourceRect), for: &sourceRect)
            }%
            let anchor = source.${side}
            rect.size.${dimension} = max(0, anchor - rect.min${axis})
            rect.origin.${axis.lower()} = anchor - rect.size.${dimension}
        }
    }
}
extension ${element}.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
            #let anchorPosition = anchor.get(for: rect, in: axis)
            #axis.set(size: max(0, axis.get(maxOf: sourceRect) - anchorPosition), for: &sourceRect)
            #axis.set(origin: anchorPosition, for: &sourceRect)
            }%
            let anchor = source.${side}
            rect.size.${dimension} = max(0, rect.max${axis} - anchor)
            rect.origin.${axis.lower()} = anchor
        }
    }
}
% end
