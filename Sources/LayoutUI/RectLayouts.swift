///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

public typealias Left = MinX.Align.MinX
public typealias Right = MaxX.Align.MaxX
public typealias Top = MinY.Align.MinY
public typealias Bottom = MaxY.Align.MaxY
public typealias CenterX = MidX.Align.MidX
public typealias CenterY = MidY.Align.MidY

public protocol WidthLayout: RectBasedLayout {}
extension Print: WidthLayout where Base: WidthLayout {}
extension Empty: WidthLayout where T: WidthLayout {}
public struct Width: WidthLayout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.width = source.size.width
    }
}
extension Width {
    public typealias Current = Empty<Width>
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with _: CGRect) {
            rect.size.width = value
        }
    }
    public struct Ratio: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.width = rect.height * value
        }
    }
}
public struct ScaledWidth<Base>: WidthLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.width *= value
    }
}
extension WidthLayout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> ScaledWidth<Self> {
        ScaledWidth(self, value: value)
    }
}
public struct InsetWidth<Base>: WidthLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.width -= value
    }
}
extension WidthLayout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> InsetWidth<Self> {
        InsetWidth(self, value: value)
    }
}
public struct BetweenWidth<Base>: WidthLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: ClosedRange<CGFloat>
    @usableFromInline
    init(_ base: Base, value: ClosedRange<CGFloat>) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.width = max(value.lowerBound, min(value.upperBound, rect.width))
    }
}
extension WidthLayout {
    @inlinable
    @inline(__always)
    public func between(_ value: ClosedRange<CGFloat>) -> BetweenWidth<Self> {
        BetweenWidth(self, value: value)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeThrough<CGFloat>) -> BetweenWidth<Self> {
        BetweenWidth(self, value: 0...value.upperBound)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeFrom<CGFloat>) -> BetweenWidth<Self> {
        BetweenWidth(self, value: value.lowerBound ... .greatestFiniteMagnitude)
    }
}
public protocol HeightLayout: RectBasedLayout {}
extension Print: HeightLayout where Base: HeightLayout {}
extension Empty: HeightLayout where T: HeightLayout {}
public struct Height: HeightLayout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.height = source.size.height
    }
}
extension Height {
    public typealias Current = Empty<Height>
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with _: CGRect) {
            rect.size.height = value
        }
    }
    public struct Ratio: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.height = rect.width * value
        }
    }
}
public struct ScaledHeight<Base>: HeightLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.height *= value
    }
}
extension HeightLayout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> ScaledHeight<Self> {
        ScaledHeight(self, value: value)
    }
}
public struct InsetHeight<Base>: HeightLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.height -= value
    }
}
extension HeightLayout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> InsetHeight<Self> {
        InsetHeight(self, value: value)
    }
}
public struct BetweenHeight<Base>: HeightLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: ClosedRange<CGFloat>
    @usableFromInline
    init(_ base: Base, value: ClosedRange<CGFloat>) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.height = max(value.lowerBound, min(value.upperBound, rect.height))
    }
}
extension HeightLayout {
    @inlinable
    @inline(__always)
    public func between(_ value: ClosedRange<CGFloat>) -> BetweenHeight<Self> {
        BetweenHeight(self, value: value)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeThrough<CGFloat>) -> BetweenHeight<Self> {
        BetweenHeight(self, value: 0...value.upperBound)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeFrom<CGFloat>) -> BetweenHeight<Self> {
        BetweenHeight(self, value: value.lowerBound ... .greatestFiniteMagnitude)
    }
}

public protocol MinXLayout: RectBasedLayout {}
extension Print: MinXLayout where Base: MinXLayout {}
public enum MinX {}
extension MinX {
    public enum Align {}
}
extension MaxX.Align {
    public struct MinX: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX - rect.size.width
        }
    }
}
extension MinX.Align {
    public struct MinX: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX
        }
    }
}
extension MidX.Align {
    public struct MinX: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX - rect.size.width * 0.5
        }
    }
}
public struct MinXOffset<Base>: MinXLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.x += value
    }
}
extension MinXLayout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> MinXOffset<Self> {
        MinXOffset(self, value: value)
    }
}
public struct MinXOffsetMultiplier<Base>: MinXLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.x += source.width * value
    }
}
extension MinXLayout {
    @inlinable
    @inline(__always)
    public func offset(multiplier value: CGFloat) -> MinXOffsetMultiplier<Self> {
        MinXOffsetMultiplier(self, value: value)
    }
}
public enum MaxX {}
extension MaxX {
    public enum Align {}
}
extension MaxX.Align {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX - rect.size.width
        }
    }
}
extension MinX.Align {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX
        }
    }
}
extension MidX.Align {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX - rect.size.width * 0.5
        }
    }
}
extension MaxX.Align.MaxX: MinXLayout {}
extension MinX.Align.MaxX: MinXLayout {}
extension MidX.Align.MaxX: MinXLayout {}
public protocol MinYLayout: RectBasedLayout {}
extension Print: MinYLayout where Base: MinYLayout {}
public enum MinY {}
extension MinY {
    public enum Align {}
}
extension MaxY.Align {
    public struct MinY: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY - rect.size.height
        }
    }
}
extension MinY.Align {
    public struct MinY: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY
        }
    }
}
extension MidY.Align {
    public struct MinY: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY - rect.size.height * 0.5
        }
    }
}
public struct MinYOffset<Base>: MinYLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.y += value
    }
}
extension MinYLayout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> MinYOffset<Self> {
        MinYOffset(self, value: value)
    }
}
public struct MinYOffsetMultiplier<Base>: MinYLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.y += source.height * value
    }
}
extension MinYLayout {
    @inlinable
    @inline(__always)
    public func offset(multiplier value: CGFloat) -> MinYOffsetMultiplier<Self> {
        MinYOffsetMultiplier(self, value: value)
    }
}
public enum MaxY {}
extension MaxY {
    public enum Align {}
}
extension MaxY.Align {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY - rect.size.height
        }
    }
}
extension MinY.Align {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY
        }
    }
}
extension MidY.Align {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY - rect.size.height * 0.5
        }
    }
}
extension MaxY.Align.MaxY: MinYLayout {}
extension MinY.Align.MaxY: MinYLayout {}
extension MidY.Align.MaxY: MinYLayout {}
public enum MidX {}
extension MidX {
    public enum Align {}
}
extension MaxX.Align {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX - rect.size.width
        }
    }
}
extension MinX.Align {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX
        }
    }
}
extension MidX.Align {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX - rect.size.width * 0.5
        }
    }
}
extension MaxX.Align.MidX: MinXLayout {}
extension MinX.Align.MidX: MinXLayout {}
extension MidX.Align.MidX: MinXLayout {}
public enum MidY {}
extension MidY {
    public enum Align {}
}
extension MaxY.Align {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY - rect.size.height
        }
    }
}
extension MinY.Align {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY
        }
    }
}
extension MidY.Align {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY - rect.size.height * 0.5
        }
    }
}
extension MaxY.Align.MidY: MinYLayout {}
extension MinY.Align.MidY: MinYLayout {}
extension MidY.Align.MidY: MinYLayout {}
