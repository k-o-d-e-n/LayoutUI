///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

public typealias Left = MinX.After.Align
public typealias Right = MaxX.Before.Align
public typealias Top = MinY.After.Align
public typealias Bottom = MaxY.Before.Align
public typealias CenterX = MidX.Center.Align
public typealias CenterY = MidY.Center.Align

public protocol WidthLayout: RectBasedLayout {}
extension Print: WidthLayout where Base: WidthLayout {}
extension Empty: WidthLayout where T: WidthLayout {}
public struct Width: WidthLayout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.width = source.size.width
    }
}
extension Width {
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.width = value
        }
    }
    public typealias Current = Empty<Width>
    // TODO: Ratio
}
public struct ScaledWidth<Base>: WidthLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.width *= value
    }
}
extension WidthLayout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> ScaledWidth<Self> {
        ScaledWidth(self, value: value)
    }
}
public struct InsetWidth<Base>: WidthLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.width -= value
    }
}
extension WidthLayout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> InsetWidth<Self> {
        InsetWidth(self, value: value)
    }
}
// TODO: Between layout
public protocol HeightLayout: RectBasedLayout {}
extension Print: HeightLayout where Base: HeightLayout {}
extension Empty: HeightLayout where T: HeightLayout {}
public struct Height: HeightLayout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.height = source.size.height
    }
}
extension Height {
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.height = value
        }
    }
    public typealias Current = Empty<Height>
    // TODO: Ratio
}
public struct ScaledHeight<Base>: HeightLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.height *= value
    }
}
extension HeightLayout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> ScaledHeight<Self> {
        ScaledHeight(self, value: value)
    }
}
public struct InsetHeight<Base>: HeightLayout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.height -= value
    }
}
extension HeightLayout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> InsetHeight<Self> {
        InsetHeight(self, value: value)
    }
}
// TODO: Between layout

public protocol MinXLayout: RectBasedLayout {}
extension Print: MinXLayout where Base: MinXLayout {}
public enum MinX {}
extension MinX {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MinX.Align {
    public typealias MaxX = LayoutUI.MinX.Before.Align
    public typealias MinX = LayoutUI.MinX.After.Align
    public typealias MidX = LayoutUI.MinX.Center.Align
}
extension MinX.Before {
    public struct Align: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX - rect.size.width
        }
    }
}
extension MinX.After {
    public struct Align: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX
        }
    }
}
extension MinX.Center {
    public struct Align: MinXLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.minX - rect.size.width * 0.5
        }
    }
}
public struct MinXOffset<Base>: MinXLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.x += value
    }
}
extension MinXLayout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> MinXOffset<Self> {
        MinXOffset(self, value: value)
    }
}
public enum MaxX {}
extension MaxX {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MaxX.Align {
    public typealias MaxX = LayoutUI.MaxX.Before.Align
    public typealias MinX = LayoutUI.MaxX.After.Align
    public typealias MidX = LayoutUI.MaxX.Center.Align
}
extension MaxX.Before {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX - rect.size.width
        }
    }
}
extension MaxX.After {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX
        }
    }
}
extension MaxX.Center {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.maxX - rect.size.width * 0.5
        }
    }
}
extension MaxX.Before.Align: MinXLayout {}
extension MaxX.After.Align: MinXLayout {}
extension MaxX.Center.Align: MinXLayout {}
public protocol MinYLayout: RectBasedLayout {}
extension Print: MinYLayout where Base: MinYLayout {}
public enum MinY {}
extension MinY {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MinY.Align {
    public typealias MaxY = LayoutUI.MinY.Before.Align
    public typealias MinY = LayoutUI.MinY.After.Align
    public typealias MidY = LayoutUI.MinY.Center.Align
}
extension MinY.Before {
    public struct Align: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY - rect.size.height
        }
    }
}
extension MinY.After {
    public struct Align: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY
        }
    }
}
extension MinY.Center {
    public struct Align: MinYLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.minY - rect.size.height * 0.5
        }
    }
}
public struct MinYOffset<Base>: MinYLayout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.y += value
    }
}
extension MinYLayout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> MinYOffset<Self> {
        MinYOffset(self, value: value)
    }
}
public enum MaxY {}
extension MaxY {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MaxY.Align {
    public typealias MaxY = LayoutUI.MaxY.Before.Align
    public typealias MinY = LayoutUI.MaxY.After.Align
    public typealias MidY = LayoutUI.MaxY.Center.Align
}
extension MaxY.Before {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY - rect.size.height
        }
    }
}
extension MaxY.After {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY
        }
    }
}
extension MaxY.Center {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.maxY - rect.size.height * 0.5
        }
    }
}
extension MaxY.Before.Align: MinYLayout {}
extension MaxY.After.Align: MinYLayout {}
extension MaxY.Center.Align: MinYLayout {}
public enum MidX {}
extension MidX {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MidX.Align {
    public typealias MaxX = LayoutUI.MidX.Before.Align
    public typealias MinX = LayoutUI.MidX.After.Align
    public typealias MidX = LayoutUI.MidX.Center.Align
}
extension MidX.Before {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX - rect.size.width
        }
    }
}
extension MidX.After {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX
        }
    }
}
extension MidX.Center {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.x = source.midX - rect.size.width * 0.5
        }
    }
}
extension MidX.Before.Align: MinXLayout {}
extension MidX.After.Align: MinXLayout {}
extension MidX.Center.Align: MinXLayout {}
public enum MidY {}
extension MidY {
    public enum Before {}
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension MidY.Align {
    public typealias MaxY = LayoutUI.MidY.Before.Align
    public typealias MinY = LayoutUI.MidY.After.Align
    public typealias MidY = LayoutUI.MidY.Center.Align
}
extension MidY.Before {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY - rect.size.height
        }
    }
}
extension MidY.After {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY
        }
    }
}
extension MidY.Center {
    public struct Align: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.y = source.midY - rect.size.height * 0.5
        }
    }
}
extension MidY.Before.Align: MinYLayout {}
extension MidY.After.Align: MinYLayout {}
extension MidY.Center.Align: MinYLayout {}
