///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

// TODO: Move all implementations to Before/After namespaces

extension MinX {
    public enum Limit {}
    public enum Pull {}
}
extension MinX.Limit {
    public typealias MaxX = LayoutUI.MinX.Before.Limit
    public typealias MinX = LayoutUI.MinX.After.Limit
}
extension MinX.Pull {
    public typealias MaxX = LayoutUI.MinX.Before.Pull
    public typealias MinX = LayoutUI.MinX.After.Pull
}
extension MinX.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MinX.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MinX.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MinX.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MaxX {
    public enum Limit {}
    public enum Pull {}
}
extension MaxX.Limit {
    public typealias MaxX = LayoutUI.MaxX.Before.Limit
    public typealias MinX = LayoutUI.MaxX.After.Limit
}
extension MaxX.Pull {
    public typealias MaxX = LayoutUI.MaxX.Before.Pull
    public typealias MinX = LayoutUI.MaxX.After.Pull
}
extension MaxX.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MaxX.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MaxX.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MaxX.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MinY {
    public enum Limit {}
    public enum Pull {}
}
extension MinY.Limit {
    public typealias MaxY = LayoutUI.MinY.Before.Limit
    public typealias MinY = LayoutUI.MinY.After.Limit
}
extension MinY.Pull {
    public typealias MaxY = LayoutUI.MinY.Before.Pull
    public typealias MinY = LayoutUI.MinY.After.Pull
}
extension MinY.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MinY.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MinY.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MinY.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
extension MaxY {
    public enum Limit {}
    public enum Pull {}
}
extension MaxY.Limit {
    public typealias MaxY = LayoutUI.MaxY.Before.Limit
    public typealias MinY = LayoutUI.MaxY.After.Limit
}
extension MaxY.Pull {
    public typealias MaxY = LayoutUI.MaxY.Before.Pull
    public typealias MinY = LayoutUI.MaxY.After.Pull
}
extension MaxY.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MaxY.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MaxY.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MaxY.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
extension MidX {
    public enum Limit {}
    public enum Pull {}
}
extension MidX.Limit {
    public typealias MinX = LayoutUI.MidX.After.Limit
    public typealias MaxX = LayoutUI.MidX.Before.Limit
}
extension MidX.Pull {
    public typealias MinX = LayoutUI.MidX.After.Pull
    public typealias MaxX = LayoutUI.MidX.Before.Pull
}
extension MidX.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MidX.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MidX.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MidX.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MidY {
    public enum Limit {}
    public enum Pull {}
}
extension MidY.Limit {
    public typealias MinY = LayoutUI.MidY.After.Limit
    public typealias MaxY = LayoutUI.MidY.Before.Limit
}
extension MidY.Pull {
    public typealias MinY = LayoutUI.MidY.After.Pull
    public typealias MaxY = LayoutUI.MidY.Before.Pull
}
extension MidY.Before {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MidY.After {
    public struct Limit: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MidY.Before {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MidY.After {
    public struct Pull: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
