///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

extension MinX {
    public enum Limit {}
    public enum Pull {}
}
extension MaxX.Limit {
    public struct MinX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MinX.Limit {
    public struct MinX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MaxX.Pull {
    public struct MinX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MinX.Pull {
    public struct MinX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MaxX {
    public enum Limit {}
    public enum Pull {}
}
extension MaxX.Limit {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MinX.Limit {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MaxX.Pull {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MinX.Pull {
    public struct MaxX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MinY {
    public enum Limit {}
    public enum Pull {}
}
extension MaxY.Limit {
    public struct MinY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MinY.Limit {
    public struct MinY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MaxY.Pull {
    public struct MinY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MinY.Pull {
    public struct MinY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.minY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
extension MaxY {
    public enum Limit {}
    public enum Pull {}
}
extension MaxY.Limit {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MinY.Limit {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MaxY.Pull {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MinY.Pull {
    public struct MaxY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.maxY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
extension MidX {
    public enum Limit {}
    public enum Pull {}
}
extension MaxX.Limit {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, min(rect.width, anchor - rect.minX))
            rect.origin.x = min(anchor, rect.minX)
        }
    }
}
extension MinX.Limit {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, min(rect.width, rect.maxX - anchor))
            rect.origin.x = max(anchor, rect.minX)
        }
    }
}
extension MaxX.Pull {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, anchor - rect.minX)
            rect.origin.x = anchor - rect.size.width
        }
    }
}
extension MinX.Pull {
    public struct MidX: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midX
            rect.size.width = max(0, rect.maxX - anchor)
            rect.origin.x = anchor
        }
    }
}
extension MidY {
    public enum Limit {}
    public enum Pull {}
}
extension MaxY.Limit {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, min(rect.height, anchor - rect.minY))
            rect.origin.y = min(anchor, rect.minY)
        }
    }
}
extension MinY.Limit {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, min(rect.height, rect.maxY - anchor))
            rect.origin.y = max(anchor, rect.minY)
        }
    }
}
extension MaxY.Pull {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, anchor - rect.minY)
            rect.origin.y = anchor - rect.size.height
        }
    }
}
extension MinY.Pull {
    public struct MidY: RectBasedLayout {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            let anchor = source.midY
            rect.size.height = max(0, rect.maxY - anchor)
            rect.origin.y = anchor
        }
    }
}
