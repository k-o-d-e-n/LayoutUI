%{
size_elements = ['Width', 'Height']
side_elements = ['MinX', 'MaxX', 'MinY', 'MaxY', 'MidX', 'MidY']
}%
///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

public typealias Left = MinX.Align.MinX
public typealias Right = MaxX.Align.MaxX
public typealias Top = MinY.Align.MinY
public typealias Bottom = MaxY.Align.MaxY
public typealias CenterX = MidX.Align.MidX
public typealias CenterY = MidY.Align.MidY

% for element in size_elements:
%{
opposite_element = 'Width' if element == 'Height' else 'Height'
}%
public protocol ${element}Layout: RectBasedLayout {}
extension Print: ${element}Layout where Base: ${element}Layout {}
extension Empty: ${element}Layout where T: ${element}Layout {}
public struct ${element}: ${element}Layout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.${element.lower()} = source.size.${element.lower()}
    }
}
extension ${element} {
    public typealias Current = Empty<${element}>
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with _: CGRect) {
            rect.size.${element.lower()} = value
        }
    }
    public struct Ratio: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.${element.lower()} = rect.${opposite_element.lower()} * value
        }
    }
}
public struct Scaled${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} *= value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> Scaled${element}<Self> {
        Scaled${element}(self, value: value)
    }
}
public struct Inset${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} -= value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> Inset${element}<Self> {
        Inset${element}(self, value: value)
    }
}
public struct Between${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: ClosedRange<CGFloat>
    @usableFromInline
    init(_ base: Base, value: ClosedRange<CGFloat>) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} = max(value.lowerBound, min(value.upperBound, rect.${element.lower()}))
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func between(_ value: ClosedRange<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: value)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeThrough<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: 0...value.upperBound)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeFrom<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: value.lowerBound ... .greatestFiniteMagnitude)
    }
}
% end

% for element in side_elements:
%{
ismin = element.startswith('Min')
ismid = element.startswith('Mid')
isX = element.endswith('X')
axis = element[-1]
dimension = 'width' if isX else 'height'
side = element[:-1].lower() + element[-1]
contrside = 'max' + element[-1] if ismin else 'min' + axis if not ismid else side
}%
% if ismin:
public protocol ${element}Layout: RectBasedLayout {}
extension Print: ${element}Layout where Base: ${element}Layout {}
% end
public enum ${element} {}
extension ${element} {
    public enum Align {}
}
extension Max${axis}.Align {
    public struct ${element}: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.${axis.lower()} = source.${side} - rect.size.${dimension}
        }
    }
}
extension Min${axis}.Align {
    public struct ${element}: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.${axis.lower()} = source.${side}
        }
    }
}
extension Mid${axis}.Align {
    public struct ${element}: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.origin.${axis.lower()} = source.${side} - rect.size.${dimension} * 0.5
        }
    }
}
% if ismin:
public struct ${element}Offset<Base>: ${element}Layout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.${element[-1].lower()} += value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> ${element}Offset<Self> {
        ${element}Offset(self, value: value)
    }
}
public struct ${element}OffsetMultiplier<Base>: ${element}Layout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.${element[-1].lower()} += source.${dimension} * value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func offset(multiplier value: CGFloat) -> ${element}OffsetMultiplier<Self> {
        ${element}OffsetMultiplier(self, value: value)
    }
}
% else:
extension Max${axis}.Align.${element}: Min${element[-1]}Layout {}
extension Min${axis}.Align.${element}: Min${element[-1]}Layout {}
extension Mid${axis}.Align.${element}: Min${element[-1]}Layout {}
% end
% end
