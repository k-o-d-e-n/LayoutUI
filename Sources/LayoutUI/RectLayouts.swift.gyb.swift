%{
size_elements = ['Width', 'Height']
side_elements = ['MinX', 'MaxX', 'MinY', 'MaxY', 'MidX', 'MidY']
}%
///
/// Generated by Swift GYB.
///

#if os(iOS) || os(tvOS) || os(macOS)
import CoreGraphics
#elseif os(Linux)
import Foundation
#endif

public typealias Left = MinX.After.Align
public typealias Right = MaxX.Before.Align
public typealias Top = MinY.After.Align
public typealias Bottom = MaxY.Before.Align
public typealias CenterX = MidX.Center.Align
public typealias CenterY = MidY.Center.Align

% for element in size_elements:
%{
contr_element = 'Width' if element == 'Height' else 'Height'
}%
public protocol ${element}Layout: RectBasedLayout {}
extension Print: ${element}Layout where Base: ${element}Layout {}
extension Empty: ${element}Layout where T: ${element}Layout {}
public struct ${element}: ${element}Layout {
    @inlinable
    @inline(__always)
    public init() {}
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        rect.size.${element.lower()} = source.size.${element.lower()}
    }
}
extension ${element} {
    public typealias Current = Empty<${element}>
    public struct Constant: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.${element.lower()} = value
        }
    }
    public struct Ratio: RectBasedLayout {
        @usableFromInline
        let value: CGFloat
        @inlinable
        @inline(__always)
        public init(_ value: CGFloat) { self.value = value }
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            rect.size.${element.lower()} = rect.${contr_element.lower()} * value
        }
    }
}
public struct Scaled${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} *= value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func scaled(_ value: CGFloat) -> Scaled${element}<Self> {
        Scaled${element}(self, value: value)
    }
}
public struct Inset${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} -= value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func inset(_ value: CGFloat) -> Inset${element}<Self> {
        Inset${element}(self, value: value)
    }
}
public struct Between${element}<Base>: ${element}Layout
where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: ClosedRange<CGFloat>
    @usableFromInline
    init(_ base: Base, value: ClosedRange<CGFloat>) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.size.${element.lower()} = max(value.lowerBound, min(value.upperBound, source.${element.lower()}))
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func between(_ value: ClosedRange<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: value)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeThrough<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: 0...value.upperBound)
    }
    @inlinable
    @inline(__always)
    public func between(_ value: PartialRangeFrom<CGFloat>) -> Between${element}<Self> {
        Between${element}(self, value: value.lowerBound ... .greatestFiniteMagnitude)
    }
}
% end

% for element in side_elements:
%{
ismin = element.startswith('Min')
ismid = element.startswith('Mid')
isX = element.endswith('X')
axis = element[-1]
dimension = 'width' if isX else 'height'
side = element[:-1].lower() + element[-1]
contrside = 'max' + element[-1] if ismin else 'min' + axis if not ismid else side
}%
% if ismin:
public protocol ${element}Layout: RectBasedLayout {}
extension Print: ${element}Layout where Base: ${element}Layout {}
% end
public enum ${element} {}
%{
_contrside = contrside[0].upper() + contrside[1:]
anchor1_typealias = _contrside if ismin else element if not ismid else 'Max' + axis
anchor1_typealias_value = 'Before'
anchor2_typealias = element if ismin else _contrside if not ismid else 'Min' + axis
anchor2_typealias_value = 'After'
}%
extension ${element} {
    @available(*, deprecated, message: "Use {constraint_anchor}.{action}.{target_anchor} pattern")
    public enum Before {}
    @available(*, deprecated, message: "Use {constraint_anchor}.{action}.{target_anchor} pattern")
    public enum After {}
    public enum Center {}
    public enum Align {}
}
extension ${element}.Align { // TODO: Change to pattern {target_anchor}.{action}.{constraint_anchor}
    public typealias ${anchor1_typealias} = LayoutUI.${element}.${anchor1_typealias_value}.Align
    public typealias ${anchor2_typealias} = LayoutUI.${element}.${anchor2_typealias_value}.Align
    public typealias Mid${axis} = LayoutUI.${element}.Center.Align
}
extension ${element}.Before {
    public struct Align: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
                #axis.set(origin: anchor.get(for: rect, in: axis) - axis.get(sizeAt: sourceRect), for: &sourceRect)
            }%
            rect.origin.${axis.lower()} = source.${side} - rect.size.${dimension}
        }
    }
}
extension ${element}.After {
    public struct Align: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
                #axis.set(origin: anchor.get(for: rect, in: axis), for: &sourceRect)
            }%
            rect.origin.${axis.lower()} = source.${side}
        }
    }
}
extension ${element}.Center {
    public struct Align: ${element + 'Layout' if ismin else 'RectBasedLayout'} {
        @inlinable
        @inline(__always)
        public init() {}
        @inlinable
        @inline(__always)
        public func layout(_ rect: inout CGRect, with source: CGRect) {
            %{
                #axis.set(origin: anchor.get(for: rect, in: axis) - axis.get(sizeAt: sourceRect) * 0.5, for: &sourceRect)
            }%
            rect.origin.${axis.lower()} = source.${side} - rect.size.${dimension} * 0.5
        }
    }
}
% if ismin:
public struct ${element}Offset<Base>: ${element}Layout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.${element[-1].lower()} += value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func offset(_ value: CGFloat) -> ${element}Offset<Self> {
        ${element}Offset(self, value: value)
    }
}
public struct ${element}OffsetMultiplier<Base>: ${element}Layout where Base: RectBasedLayout {
    @usableFromInline
    let base: Base
    @usableFromInline
    let value: CGFloat
    @usableFromInline
    init(_ base: Base, value: CGFloat) {
        self.base = base; self.value = value
    }
    @inlinable
    @inline(__always)
    public func layout(_ rect: inout CGRect, with source: CGRect) {
        base.layout(&rect, with: source)
        rect.origin.${element[-1].lower()} += source.${dimension} * value
    }
}
extension ${element}Layout {
    @inlinable
    @inline(__always)
    public func offset(multiplier value: CGFloat) -> ${element}OffsetMultiplier<Self> {
        ${element}OffsetMultiplier(self, value: value)
    }
}
% else:
extension ${element}.Before.Align: Min${element[-1]}Layout {}
extension ${element}.After.Align: Min${element[-1]}Layout {}
extension ${element}.Center.Align: Min${element[-1]}Layout {}
% end
% end
