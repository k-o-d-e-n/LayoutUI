%{
side_elements = ['MinX', 'MaxX', 'MinY', 'MaxY', 'MidX', 'MidY']
}%
///
/// Generated by Swift GYB.
///

import XCTest
@testable import LayoutUI

extension CGRect {
    static func random(in source: CGRect) -> CGRect {
        let randomValue: (CGFloat) -> CGFloat = { pattern -> CGFloat in
            #if os(Linux)
            return CGFloat(SwiftGlibc.random() % Int(pattern))
            #else
            return CGFloat(arc4random_uniform(UInt32(pattern)))
            #endif
        }
        let o = CGPoint(x: randomValue(source.width), y: randomValue(source.height))
        let s = CGSize(width: randomValue(source.width - o.x), height: randomValue(source.height - o.y))
        return CGRect(origin: o, size: s)
    }
}

// TODO: Add visual tests through SwiftUI Preview

class LayoutUITests: XCTestCase {
    let bounds = CGRect(x: 0, y: 0, width: 1024, height: 800)

    override func setUp() {
        super.setUp()
    }
    override func tearDown() {
        super.tearDown()
    }
}
extension LayoutUITests {
% for element in side_elements:
%{
ismin = element.startswith('Min')
ismid = element.startswith('Mid')
isX = element.endswith('X')
axis = element[-1]
dimension = 'width' if isX else 'height'
side = element[:-1].lower() + element[-1]
contrside = 'max' + axis if ismin else 'min' + axis if not ismid else side
}%
    func test${element}AlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = ${element}.${'After' if ismin else 'Before'}.Align()
        alignment.layout(&view1, with: view2)
        % if ismid:
        XCTAssertTrue(view1.max${axis} == view2.${side})
        % else:
        XCTAssertTrue(view1.${side} == view2.${side})
        % end
    }
    func test${element}AlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = ${element}.${'Before' if ismin else 'After'}.Align()
        alignment.layout(&view1, with: view2)
        % if ismid:
        XCTAssertTrue(view1.min${axis} == view2.${side})
        % else:
        XCTAssertTrue(view1.${contrside} == view2.${side})
        % end
    }
    func test${element}AlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = ${element}.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.mid${axis} == view2.${side})
    }
% if True: #not element.startswith('Mid'):
    func test${element}Limit() {
        %{
        leftRect = 'rect4' if ismin else 'rect3'
        rightRect = 'rect3' if ismin else 'rect4'
        }%
        let limit = ${element}.${'After' if ismin or ismid else 'Before'}.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let ${'shouldCollapsed' if ismin or ismid else 'shouldNotChanged'} = rect3.${contrside if ismin else side if not ismid else 'max' + axis} <= rect4.${side}
        let ${'shouldNotChanged' if ismin or ismid else 'shouldCollapsed'} = rect3.${side if ismin else contrside if not ismid else 'min' + axis} >= rect4.${side}

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.${side if ismin else contrside if not ismid else 'min' + axis} == rect4.${side})
            XCTAssertTrue(resultRect3.${contrside if ismin else side if not ismid else 'max' + axis} == rect4.${side})
        } else {
            XCTAssertTrue(resultRect3.${side if not ismid else 'min' + axis} == rect4.${side})
            % if not ismid:
            XCTAssertTrue(resultRect3.${dimension} == rect3.divided(atDistance: ${leftRect}.${side} - ${rightRect}.${side}, from: .${side}Edge).remainder.${dimension})
            % else:
            // TODO: Check dimension
            % end
        }
    }
    func test${element}LimitOuter() {
        %{
        leftRect = 'rect2' if ismin or ismid else 'rect1'
        rightRect = 'rect1' if ismin or ismid else 'rect2'
        }%
        let limit = ${element}.${'Before' if ismin or ismid else 'After'}.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let ${'shouldNotChanged' if ismin or ismid else 'shouldCollapsed'} = rect1.${contrside if ismin else side if not ismid else 'max' + axis} <= rect2.${side}
        let ${'shouldCollapsed' if ismin or ismid else 'shouldNotChanged'} = rect1.${side if ismin else contrside if not ismid else 'min' + axis} >= rect2.${side}

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.${contrside if ismin else side if not ismid else 'max' + axis} == rect2.${side})
            XCTAssertTrue(resultRect1.${side if ismin else contrside if not ismid else 'min' + axis} == rect2.${side})
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.${contrside if not ismid else 'max' + axis} == rect2.${side})
            XCTAssertTrue(resultRect1.${dimension} == ${leftRect}.${side} - ${rightRect}.${side if not ismid else 'min' + axis})
        }
    }
    func test${element}Pull() {
        %{
        maxRect = 'rect3' if ismin or ismid else 'rect4'
        minRect = 'rect4' if ismin or ismid else 'rect3'
        }%
        let pull = ${element}.${'After' if ismin or ismid else 'Before'}.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        ${'// TODO: It seems condition for not change' if not ismin or ismid else ''}
        let shouldChangeContrSide = rect3.${contrside if not ismid else 'max' + axis} < rect4.${side}

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.${side if not ismid else 'min' + axis} == rect4.${side})
        XCTAssertTrue(resultRect3.${dimension} == max(0, ${maxRect}.max${axis} - ${minRect + ('.min' + axis if not ismid else '.' + side)}))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.${contrside if not ismid else 'max' + axis} == ${minRect + ('.min' + axis if not ismid else '.' + side)})
        }
    }
    func test${element}PullOuter() {
        %{
        leftRect = 'rect2' if ismin or ismid else 'rect1'
        rightRect = 'rect1' if ismin or ismid else 'rect2'
        compare = '<' if ismin or ismid else '>'
        }%
        let pull = ${element}.${'Before' if ismin or ismid else 'After'}.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.${side if not ismid else 'min' + axis} ${compare} rect2.${side}

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.${contrside if not ismid else 'max' + axis} == rect2.${side})
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.${dimension} == ${leftRect}.${side} - ${rightRect}.${side if not ismid else 'min' + axis})
        }
    }
% else:

% end
% if not element.startswith('Center'):

% else:

% end
% end
}
