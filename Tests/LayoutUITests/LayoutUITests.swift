///
/// Generated by Swift GYB.
///

import XCTest
@testable import LayoutUI

extension CGRect {
    static func random(in source: CGRect) -> CGRect {
        let randomValue: (CGFloat) -> CGFloat = { pattern -> CGFloat in
            #if os(Linux)
            return CGFloat(SwiftGlibc.random() % Int(pattern))
            #else
            return CGFloat(arc4random_uniform(UInt32(pattern)))
            #endif
        }
        let o = CGPoint(x: randomValue(source.width), y: randomValue(source.height))
        let s = CGSize(width: randomValue(source.width - o.x), height: randomValue(source.height - o.y))
        return CGRect(origin: o, size: s)
    }
}

// TODO: Add visual tests through SwiftUI Preview

class LayoutUITests: XCTestCase {
    let bounds = CGRect(x: 0, y: 0, width: 1024, height: 800)

    override func setUp() {
        super.setUp()
    }
    override func tearDown() {
        super.tearDown()
    }
}
extension LayoutUITests {
    func testMinXAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinX.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minX == view2.minX)
    }
    func testMinXAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinX.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxX == view2.minX)
    }
    func testMinXAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinX.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midX == view2.minX)
    }
    func testMinXLimit() {
        let limit = MinX.After.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldCollapsed = rect3.maxX <= rect4.minX
        let shouldNotChanged = rect3.minX >= rect4.minX

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minX == rect4.minX)
            XCTAssertTrue(resultRect3.maxX == rect4.minX)
        } else {
            XCTAssertTrue(resultRect3.minX == rect4.minX)
            XCTAssertTrue(resultRect3.width == rect3.divided(atDistance: rect4.minX - rect3.minX, from: .minXEdge).remainder.width)
        }
    }
    func testMinXLimitOuter() {
        let limit = MinX.Before.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldNotChanged = rect1.maxX <= rect2.minX
        let shouldCollapsed = rect1.minX >= rect2.minX

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxX == rect2.minX)
            XCTAssertTrue(resultRect1.minX == rect2.minX)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.maxX == rect2.minX)
            XCTAssertTrue(resultRect1.width == rect2.minX - rect1.minX)
        }
    }
    func testMinXPull() {
        let pull = MinX.After.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        
        let shouldChangeContrSide = rect3.maxX < rect4.minX

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.minX == rect4.minX)
        XCTAssertTrue(resultRect3.width == max(0, rect3.maxX - rect4.minX))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.maxX == rect4.minX)
        }
    }
    func testMinXPullOuter() {
        let pull = MinX.Before.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.minX < rect2.minX

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.maxX == rect2.minX)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.width == rect2.minX - rect1.minX)
        }
    }

    func testMaxXAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxX.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxX == view2.maxX)
    }
    func testMaxXAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxX.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minX == view2.maxX)
    }
    func testMaxXAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxX.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midX == view2.maxX)
    }
    func testMaxXLimit() {
        let limit = MaxX.Before.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldNotChanged = rect3.maxX <= rect4.maxX
        let shouldCollapsed = rect3.minX >= rect4.maxX

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minX == rect4.maxX)
            XCTAssertTrue(resultRect3.maxX == rect4.maxX)
        } else {
            XCTAssertTrue(resultRect3.maxX == rect4.maxX)
            XCTAssertTrue(resultRect3.width == rect3.divided(atDistance: rect3.maxX - rect4.maxX, from: .maxXEdge).remainder.width)
        }
    }
    func testMaxXLimitOuter() {
        let limit = MaxX.After.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldCollapsed = rect1.maxX <= rect2.maxX
        let shouldNotChanged = rect1.minX >= rect2.maxX

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxX == rect2.maxX)
            XCTAssertTrue(resultRect1.minX == rect2.maxX)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.minX == rect2.maxX)
            XCTAssertTrue(resultRect1.width == rect1.maxX - rect2.maxX)
        }
    }
    func testMaxXPull() {
        let pull = MaxX.Before.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        // TODO: It seems condition for not change
        let shouldChangeContrSide = rect3.minX < rect4.maxX

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.maxX == rect4.maxX)
        XCTAssertTrue(resultRect3.width == max(0, rect4.maxX - rect3.minX))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.minX == rect3.minX)
        }
    }
    func testMaxXPullOuter() {
        let pull = MaxX.After.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.maxX > rect2.maxX

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.minX == rect2.maxX)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.width == rect1.maxX - rect2.maxX)
        }
    }

    func testMinYAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinY.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minY == view2.minY)
    }
    func testMinYAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinY.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxY == view2.minY)
    }
    func testMinYAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MinY.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midY == view2.minY)
    }
    func testMinYLimit() {
        let limit = MinY.After.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldCollapsed = rect3.maxY <= rect4.minY
        let shouldNotChanged = rect3.minY >= rect4.minY

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minY == rect4.minY)
            XCTAssertTrue(resultRect3.maxY == rect4.minY)
        } else {
            XCTAssertTrue(resultRect3.minY == rect4.minY)
            XCTAssertTrue(resultRect3.height == rect3.divided(atDistance: rect4.minY - rect3.minY, from: .minYEdge).remainder.height)
        }
    }
    func testMinYLimitOuter() {
        let limit = MinY.Before.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldNotChanged = rect1.maxY <= rect2.minY
        let shouldCollapsed = rect1.minY >= rect2.minY

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxY == rect2.minY)
            XCTAssertTrue(resultRect1.minY == rect2.minY)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.maxY == rect2.minY)
            XCTAssertTrue(resultRect1.height == rect2.minY - rect1.minY)
        }
    }
    func testMinYPull() {
        let pull = MinY.After.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        
        let shouldChangeContrSide = rect3.maxY < rect4.minY

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.minY == rect4.minY)
        XCTAssertTrue(resultRect3.height == max(0, rect3.maxY - rect4.minY))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.maxY == rect4.minY)
        }
    }
    func testMinYPullOuter() {
        let pull = MinY.Before.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.minY < rect2.minY

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.maxY == rect2.minY)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.height == rect2.minY - rect1.minY)
        }
    }

    func testMaxYAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxY.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxY == view2.maxY)
    }
    func testMaxYAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxY.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minY == view2.maxY)
    }
    func testMaxYAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MaxY.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midY == view2.maxY)
    }
    func testMaxYLimit() {
        let limit = MaxY.Before.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldNotChanged = rect3.maxY <= rect4.maxY
        let shouldCollapsed = rect3.minY >= rect4.maxY

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minY == rect4.maxY)
            XCTAssertTrue(resultRect3.maxY == rect4.maxY)
        } else {
            XCTAssertTrue(resultRect3.maxY == rect4.maxY)
            XCTAssertTrue(resultRect3.height == rect3.divided(atDistance: rect3.maxY - rect4.maxY, from: .maxYEdge).remainder.height)
        }
    }
    func testMaxYLimitOuter() {
        let limit = MaxY.After.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldCollapsed = rect1.maxY <= rect2.maxY
        let shouldNotChanged = rect1.minY >= rect2.maxY

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxY == rect2.maxY)
            XCTAssertTrue(resultRect1.minY == rect2.maxY)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.minY == rect2.maxY)
            XCTAssertTrue(resultRect1.height == rect1.maxY - rect2.maxY)
        }
    }
    func testMaxYPull() {
        let pull = MaxY.Before.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        // TODO: It seems condition for not change
        let shouldChangeContrSide = rect3.minY < rect4.maxY

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.maxY == rect4.maxY)
        XCTAssertTrue(resultRect3.height == max(0, rect4.maxY - rect3.minY))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.minY == rect3.minY)
        }
    }
    func testMaxYPullOuter() {
        let pull = MaxY.After.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.maxY > rect2.maxY

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.minY == rect2.maxY)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.height == rect1.maxY - rect2.maxY)
        }
    }

    func testMidXAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidX.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxX == view2.midX)
    }
    func testMidXAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidX.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minX == view2.midX)
    }
    func testMidXAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidX.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midX == view2.midX)
    }
    func testMidXLimit() {
        let limit = MidX.After.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldCollapsed = rect3.maxX <= rect4.midX
        let shouldNotChanged = rect3.minX >= rect4.midX

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minX == rect4.midX)
            XCTAssertTrue(resultRect3.maxX == rect4.midX)
        } else {
            XCTAssertTrue(resultRect3.minX == rect4.midX)
            // TODO: Check dimension
        }
    }
    func testMidXLimitOuter() {
        let limit = MidX.Before.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldNotChanged = rect1.maxX <= rect2.midX
        let shouldCollapsed = rect1.minX >= rect2.midX

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxX == rect2.midX)
            XCTAssertTrue(resultRect1.minX == rect2.midX)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.maxX == rect2.midX)
            XCTAssertTrue(resultRect1.width == rect2.midX - rect1.minX)
        }
    }
    func testMidXPull() {
        let pull = MidX.After.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        // TODO: It seems condition for not change
        let shouldChangeContrSide = rect3.maxX < rect4.midX

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.minX == rect4.midX)
        XCTAssertTrue(resultRect3.width == max(0, rect3.maxX - rect4.midX))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.maxX == rect4.midX)
        }
    }
    func testMidXPullOuter() {
        let pull = MidX.Before.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.minX < rect2.midX

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.maxX == rect2.midX)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.width == rect2.midX - rect1.minX)
        }
    }

    func testMidYAlignmentInner() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidY.Before.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.maxY == view2.midY)
    }
    func testMidYAlignmentOuter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidY.After.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.minY == view2.midY)
    }
    func testMidYAlignmentCenter() {
        var view1 = CGRect.random(in: bounds)
        let view2 = CGRect.random(in: bounds)
        let alignment = MidY.Center.Align()
        alignment.layout(&view1, with: view2)
        XCTAssertTrue(view1.midY == view2.midY)
    }
    func testMidYLimit() {
        let limit = MidY.After.Limit()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        let shouldCollapsed = rect3.maxY <= rect4.midY
        let shouldNotChanged = rect3.minY >= rect4.midY

        var resultRect3 = rect3
        limit.layout(&resultRect3, with: rect4)

        if shouldNotChanged {
            XCTAssertTrue(resultRect3 == rect3)
        } else if shouldCollapsed {
            XCTAssertTrue(resultRect3.minY == rect4.midY)
            XCTAssertTrue(resultRect3.maxY == rect4.midY)
        } else {
            XCTAssertTrue(resultRect3.minY == rect4.midY)
            // TODO: Check dimension
        }
    }
    func testMidYLimitOuter() {
        let limit = MidY.Before.Limit()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldNotChanged = rect1.maxY <= rect2.midY
        let shouldCollapsed = rect1.minY >= rect2.midY

        var resultRect1 = rect1
        limit.layout(&resultRect1, with: rect2)

        if shouldCollapsed {
            XCTAssertTrue(resultRect1.maxY == rect2.midY)
            XCTAssertTrue(resultRect1.minY == rect2.midY)
        } else if shouldNotChanged {
            XCTAssertTrue(resultRect1 == rect1)
        } else {
            XCTAssertTrue(resultRect1.maxY == rect2.midY)
            XCTAssertTrue(resultRect1.height == rect2.midY - rect1.minY)
        }
    }
    func testMidYPull() {
        let pull = MidY.After.Pull()
        let rect3 = CGRect.random(in: bounds)
        let rect4 = CGRect.random(in: bounds)
        // TODO: It seems condition for not change
        let shouldChangeContrSide = rect3.maxY < rect4.midY

        var resultRect3 = rect3
        pull.layout(&resultRect3, with: rect4)

        XCTAssertTrue(resultRect3.minY == rect4.midY)
        XCTAssertTrue(resultRect3.height == max(0, rect3.maxY - rect4.midY))
        if shouldChangeContrSide {
            XCTAssertTrue(resultRect3.maxY == rect4.midY)
        }
    }
    func testMidYPullOuter() {
        let pull = MidY.Before.Pull()
        let rect1 = CGRect.random(in: bounds)
        let rect2 = CGRect.random(in: bounds)
        let shouldChangeWidth = rect1.minY < rect2.midY

        var resultRect1 = rect1
        pull.layout(&resultRect1, with: rect2)
        XCTAssertTrue(resultRect1.maxY == rect2.midY)
        if shouldChangeWidth {
            XCTAssertTrue(resultRect1.height == rect2.midY - rect1.minY)
        }
    }

}
